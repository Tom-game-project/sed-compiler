fn is_empty a:bit32 -> bool {
    sed ${
        "s/~$/T/  ",
        "s/~.*$/F/",
        "s/T/~1;/ ",
        "s/F/~0;/ ",
    }$
}

fn shift_left1 a:bit32 -> bit32 {
    sed ${
        "s/\\(~[01]*\\)/\\10;/"
    }$
}

fn shift_right1 a:bit32 -> bit32 {
    sed ${
        "s/\\(~[01]*\\)[01]/\\1;/"
    }$
}

fn ends_with_zero a:bit32 -> bool {
    sed ${
        "s/.*0$/~1;/ ",
        "s/.*1$/~0;/ ", 
    }$
}

fn zero_padding32 a:bit32 -> bit32 {
    sed${
        "s/~\\([^\\~]*\\)/\\1/",
        "s/^/00000000000000000000000000000000/",
        "s/.*\\(................................\\)$/~\\1;/",
    }$
}

pub fn add a:bit32, b:bit32 -> bit32 {
    sed ${
        "s/~\\([^\\~]*\\)~\\([^\\~]*\\)/add 0;;\\1;\\2;/",
        "b addloop",
        ":addloop",
        "s/add 1;\\([01]*\\);;;/1\\1/",
        "s/add 0;\\([01]*\\);;;/\\1/",
        "s/add \\([01]\\);\\([01]*\\);\\([01]*\\);;/add \\1;\\2;\\3;0;/",
        "s/add \\([01]\\);\\([01]*\\);;\\([01]*\\);/add \\1;\\2;0;\\3;/",
        "s/add \\([01]\\);\\([01]*\\);\\([01]*\\)\\([01]\\);\\([01]*\\)\\([01]\\);/add \\1\\4\\6;\\2;\\3;\\5;/",
        "s/add 000;\\([01]*\\);\\([01]*\\);\\([01]*\\);/add 0;0\\1;\\2;\\3;/",
        "s/add 001;\\([01]*\\);\\([01]*\\);\\([01]*\\);/add 0;1\\1;\\2;\\3;/",
        "s/add 010;\\([01]*\\);\\([01]*\\);\\([01]*\\);/add 0;1\\1;\\2;\\3;/",
        "s/add 011;\\([01]*\\);\\([01]*\\);\\([01]*\\);/add 1;0\\1;\\2;\\3;/",
        "s/add 100;\\([01]*\\);\\([01]*\\);\\([01]*\\);/add 0;1\\1;\\2;\\3;/",
        "s/add 101;\\([01]*\\);\\([01]*\\);\\([01]*\\);/add 1;0\\1;\\2;\\3;/",
        "s/add 110;\\([01]*\\);\\([01]*\\);\\([01]*\\);/add 1;0\\1;\\2;\\3;/",
        "s/add 111;\\([01]*\\);\\([01]*\\);\\([01]*\\);/add 1;1\\1;\\2;\\3;/",
        "t addloop",
        "s/\\(.*\\)/~\\1;/",
    }$
}

pub fn mul a:bit32, b:bit32 -> bit32 {
    let r = 0;
    if is_empty(b) {
        r = 0;
    } else {
        if ends_with_zero(b) {
            r = mul(shift_left1(a), shift_right1(b));
        } else {
            r = add(a, mul(shift_left1(a), shift_right1(b)));
        }
    }
    return r;
}

fn twos_complement a:bit32 -> bit32 {
    sed ${
        "s/~\\([^\\~]*\\)/\\1/",
        "y/01/10/",
        "s/$/+/",
        ":add_one_loop",
        "s/0+$/1/",
        "t add_one_done",
        "s/1+$/+0/",
        "b add_one_loop",
        ":add_one_done",
        "s/^\\+/1/",
        "s/\\(.*\\)/~\\1;/",
    }$
}

pub fn sub32 a:bit32, b:bit32 -> bit32 {
    return zero_padding32(add(zero_padding32(a), twos_complement(zero_padding32(b))));
}

// 大小関係を記号で変換する関数
fn relation a:bit32, b:bit32 -> char
{
    sed ${
        "s/~\\([01]*\\)~\\([01]*\\)/\\1=\\2/",
        ":compare_loop",
        "s/\\([01]\\)\\([01]*\\)=\\([01]\\)\\([01]*\\)/\\1;\\3;\\2=\\4/",
        "",
        "/^1;1;/ {",
        "    s/^1;1;\\(.\\+\\)/\\1/",
        "    bcompare_loop",
        "}",
        "/^0;0;/ {",
        "    s/^0;0;\\(.\\+\\)/\\1/",
        "    bcompare_loop",
        "}",
        "/^1;0;\\(.*\\)/ {",
        "    s/.*/>/",
        "}",
        "/^0;1;/ {",
        "    s/.*/</",
        "}",
	"s/\\(.*\\)/~\\1;/"
    }$
}

fn is_greater_or_equal a:char -> bool {
    sed ${
        "s/^~>$/~1;/",
        "s/^~=$/~1;/",
        "s/^~<$/~0;/",
    }$
}

fn headtail a:bit32 -> bool, bool {
    sed ${
        "s/~\\([10]\\)[01]*\\([01]\\)/~\\1~\\2;/",
    }$
}

pub fn entry -> bit32 {
    let a = 5;
    let b = 101;

    // return mul(a, add(a, b)), add(a, b);
    // return twos_complement(a);
    // return sub32(b, a);
    return is_greater_or_equal(relation(a, b));
}
