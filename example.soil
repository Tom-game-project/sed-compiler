fn is_empty a:bit32 -> bool {
    sed ${
        "s/~$/T/  ",
        "s/~.*$/F/",
        "s/T/~1;/ ",
        "s/F/~0;/ ",
    }$
}

fn shift_left1 a:bit32 -> bit32 {
    sed ${
        "s/\\(~[01]*\\)/\\10;/"
    }$
}

fn shift_right1 a:bit32 -> bit32 {
    sed ${
        "s/\\(~[01]*\\)[01]/\\1;/"
    }$
}

fn ends_with_zero a:bit32 -> bool {
    sed ${
        "s/.*0$/~1;/ ",
        "s/.*1$/~0;/ ", 
    }$
}

fn zero_padding32 a:bit32 -> bit32 {
    sed${
        "s/~\\([^\\~]*\\)/\\1/",
        "s/^/00000000000000000000000000000000/",
        "s/.*\\(................................\\)$/~\\1;/",
    }$
}

pub fn add a:bit32, b:bit32 -> bit32 {
    sed ${
        "s/~\\([^\\~]*\\)~\\([^\\~]*\\)/add 0;;\\1;\\2;/",
        "b addloop",
        ":addloop",
        "s/add 1;\\([01]*\\);;;/1\\1/",
        "s/add 0;\\([01]*\\);;;/\\1/",
        "s/add \\([01]\\);\\([01]*\\);\\([01]*\\);;/add \\1;\\2;\\3;0;/",
        "s/add \\([01]\\);\\([01]*\\);;\\([01]*\\);/add \\1;\\2;0;\\3;/",
        "s/add \\([01]\\);\\([01]*\\);\\([01]*\\)\\([01]\\);\\([01]*\\)\\([01]\\);/add \\1\\4\\6;\\2;\\3;\\5;/",
        "s/add 000;\\([01]*\\);\\([01]*\\);\\([01]*\\);/add 0;0\\1;\\2;\\3;/",
        "s/add 001;\\([01]*\\);\\([01]*\\);\\([01]*\\);/add 0;1\\1;\\2;\\3;/",
        "s/add 010;\\([01]*\\);\\([01]*\\);\\([01]*\\);/add 0;1\\1;\\2;\\3;/",
        "s/add 011;\\([01]*\\);\\([01]*\\);\\([01]*\\);/add 1;0\\1;\\2;\\3;/",
        "s/add 100;\\([01]*\\);\\([01]*\\);\\([01]*\\);/add 0;1\\1;\\2;\\3;/",
        "s/add 101;\\([01]*\\);\\([01]*\\);\\([01]*\\);/add 1;0\\1;\\2;\\3;/",
        "s/add 110;\\([01]*\\);\\([01]*\\);\\([01]*\\);/add 1;0\\1;\\2;\\3;/",
        "s/add 111;\\([01]*\\);\\([01]*\\);\\([01]*\\);/add 1;1\\1;\\2;\\3;/",
        "t addloop",
        "s/\\(.*\\)/~\\1;/",
    }$
}

pub fn mul a:bit32, b:bit32 -> bit32 {
    let r = 0;
    if is_empty(b) {
        r = 0;
    } else {
        if ends_with_zero(b) {
            r = mul(shift_left1(a), shift_right1(b));
        } else {
            r = add(a, mul(shift_left1(a), shift_right1(b)));
        }
    }
    return r;
}

fn twos_complement a:bit32 -> bit32 {
    sed ${
        "s/~\\([^\\~]*\\)/\\1/",
        "y/01/10/",
        "s/$/+/",
        ":add_one_loop",
        "s/0+$/1/",
        "t add_one_done",
        "s/1+$/+0/",
        "b add_one_loop",
        ":add_one_done",
        "s/^\\+/1/",
        "s/\\(.*\\)/~\\1;/",
    }$
}

pub fn sub32 a:bit32, b:bit32 -> bit32 {
    return zero_padding32(add(zero_padding32(a), twos_complement(zero_padding32(b))));
}

// 大小関係を記号で変換する関数
fn relation a:bit32, b:bit32 -> char
{
    sed ${
        "s/~\\([01]*\\)~\\([01]*\\)/\\1=\\2/",
        ":compare_loop",
        "s/\\([01]\\)\\([01]*\\)=\\([01]\\)\\([01]*\\)/\\1;\\3;\\2=\\4/",
        "",
        "/^1;1;/ {",
        "    s/^1;1;\\(.\\+\\)/\\1/",
        "    bcompare_loop",
        "}",
        "/^0;0;/ {",
        "    s/^0;0;\\(.\\+\\)/\\1/",
        "    bcompare_loop",
        "}",
        "/^1;0;\\(.*\\)/ {",
        "    s/.*/>/",
        "}",
        "/^0;1;/ {",
        "    s/.*/</",
        "}",
	"s/\\(.*\\)/~\\1;/"
    }$
}

fn is_greater_or_equal a:char -> bool {
    sed ${
        "s/^~>$/~1;/",
        "s/^~=$/~1;/",
        "s/^~<$/~0;/",
    }$
}


fn lstrip0 a:str -> str {
    sed ${
        "s/~[0]*\\([01]*\\)$/~\\1;/",
	"s/~;$/~0;/"
    }$
}

fn headtail a:bit32 -> bool, str {
    sed ${
        "s/~\\([10]\\)\\([01]*\\)$/~\\1~\\2;/",
    }$
}


fn concat_str_1 a:bit32 -> bit33 {
    sed ${
        "s/~\\([10]*\\)/~\\11;/",
    }$
}

fn concat_str_0 a:bit32 -> bit33 {
    sed ${
        "s/~\\([10]*\\)/~\\10;/",
    }$
}

fn concat a:str, b:str -> str {
    sed ${
        "s/~\\([10]*\\)~\\([10]*\\)/~\\1\\2;/",
    }$
}

fn const_none_string -> str {
    sed ${
        "s/.*/~;/",
    }$
}

fn div_mod_rec N_rem: bit32, Q: bit32, R: bit32, D: bit32 -> bit32, bit32 {
    let r1 = 0; // init
    let r2 = 0; // init

    if is_empty(N_rem) {
        r1 = Q;
	r2 = R;
    } else {
        let head = 0; // init 1bit
        let tail = 0; // init 1bit
        
        let R_next = 0; // init
        let Q_next = 0; // init

        head, tail = headtail(N_rem);
        let R_new = lstrip0(concat(R, head));
        if is_greater_or_equal(relation(zero_padding32(R_new), D)) {
            R_next = sub32(R_new, D);
            Q_next = concat_str_1(Q);
        } else {
            R_next = R_new;
            Q_next = concat_str_0(Q);
        }
        r1, r2 = div_mod_rec(tail, Q_next, R_next, D)
    }
    return r1, r2;
}

fn const_return -> bit32, bit32 {
    return 101, 5;
}

pub fn entry -> bit32, bit32, bit32 {
    let a = 0;
    let b = 0;
    let r1 = 0;
    let r2 = 0;

    a, b = const_return();

    // r1, r2 = headtail(a); 
    r1, r2 = div_mod_rec(a, const_none_string(), const_none_string(), b);
    return const_none_string(), r1, r2;
}

